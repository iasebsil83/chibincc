t0 Nested Calls Syntax Specification

l This document describes briefly the structure of the \bN\bested \bC\balls (NC) syntax.
l It also gives elements on how chibincc (first official NC compiler) parses it.

b

%






t1 Presentation

t2 Brief description

p The NC syntax, as the name implies, is a programming syntax (or language) consisting in function calls only (or almost). \
NC is very \blow-level\b and \bstrict\b. \
We can even say it is \cff0000highly restrictive\c and so not really suited for \uhuman development\u, \
but rather to be generated as the output of a higher-level compiler for example.

p The objective of this syntax is to have a low-level interface with assembly code, as the C programming language does, \
but also to be \bsimple\b to parse without any \uambiguity\u and \uundefined behavior\u.



t2 NC content and Parsing

p The NC syntax is text-based and also ASCII-only compliant. \
That means every single byte in an NC code must be ASCII or the full code will be rejected.

p \u\bDISCLAIMER :\b\u That doesn't mean non-ASCII characters cannot be used as values in our program. \
Any literal value can be represented in NC and this is made using only ASCII characters.

p NC intsruction are read line by line, one instruction per line, no exception. \
No "comment" feature exists (=> no comments allowed). \
Indent is allowed for better visualisation and debugging however it is not used for any purpose in the parsing process. \
Empty lines are ignored.

p Because NC is text-based, it is easier to debug it than if we were using binary characters or specific encodings. \
However, each NC instruction is composed of \useveral fixed-length fields\u, meaning we \udon't need\u to separate them \
to have a working parsable content. \
For this reason, at first sight, you may find NC completely unreadable for human (hard to debug). \
This is why I \b\cff0000highly\c\b recommend to use an NC syntax coloration in your text editor when reading NC code.



t2 Generic VALUE items

p There is one item we must present to understand how some NC instruction fields are parsed : VALUES. \
When expecting to have a value, the first character will be read to guess what kind of value we have. \
Depending on this, our value can be either a \bliteral value\b, a \bdata item name\b or a \bnon-void returning function call (!vfc)\b.


t3 Literal value

p If it is a number, we allow digits \m1\m, \m2\m, \m4\m and \m8\m to tell whether the following will be a literal value on 1, 2, 4 or 8 bytes. \
The following value must be written in \u\blowercase hexadecimal\b\u so the lengths of such values will be 2, 4, 8 and 16 digits. \
\c\bEvery digit is required every time.\b\c


t3 Data Item name

p If the first character of a value is a letter (lowercase \band\b uppercase included), one of the 2 remaining possibilities can match. \
Continuing to read our value, from the second character to the end, we only allow to have both letters \u\band\b\u numbers as current value name. \
As soon as we reach an openning brace delimiter \m{\m or the end of line, the resulted name will be considerated as a data item giving its value. \
By the way, because we need to have a first character to detect whether our value is a data item or not, we cannot have empty data item names.


t3 Non-void Returning Function Call

p Finally, when reading a value name as for data item matching, a last case can happen. \
If the next character following our name is an openning parenthesis \m(\m, we are now having a non-void returning function call with the given value name as function name. \
By the way, because we need to have a first character to detect whether our value is a function call or not, we cannot have empty function names.

p One \bhighly important thing\b about function calls is that they can be \unested\u together with other values. \
This is basically the main reason why this syntax is called NC and the main principle behind it. \
After a function's openning parenthesis, we must have an end of line. <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< MAYBE NOT ?



t2 Nested instructions

p Some instructions may require to use parenthesis or brace delimiters \m(\m, \m)\m and \m{\m, \m}\m. \
These are used to define whether a certain number of instructions are \u\bnested\b\u into some other. \
However there is a tiny detail that deserves to pay attention with this.

p We saw that parentheses are used for function calls : this is infact the only use they have. \
We also saw that to detect a function call in values, we \bmust\b have the openning parenthesis to figure out the data item type






t1 Full NC description

t2 First rank : ROLE

p Each line must start with a ROLE character. \
Depending on that, the rest of the line will be analyzed differently. \
- \md\m : Definition
Definitions of data structures to be taken into account during compilation \
as well as element to be stored in the resulting executable (global) or not (local).
-
- \mx\m : Execution
Very basic runnable instruction using literal values or already defined elements.
-

p In chibincc, the ROLE information is stored as part of the instruction ID : \
1st bit is 0 for DEF, 1 for EXE.



t2 Second rank : DEF SCOPE

p Following a DEF, another character is expected : its SCOPE.
- \mi\m : Intern
Definition is accessible only within the current program.
-
- \mx\m : Extern
Definition does not exist in the current program, it refers to another program's shared definition.
-
- \ms\m : Shared
Definition is accessible within the current program and also by other external programs.
-
- \ml\m : Local
Definition is accessible within its local scope only.
-

p In chibincc, the SCOPE information is stored as part of the instruction ID : \
2nd & 3rd bits are used :
- \m00\m : \mi\m (internal)
-
- \m01\m : \mx\m (external)
-
- \m10\m : \ms\m (shared)
-
- \m11\m : undefined (will cause an "Undefined instruction ID" error)
-



t2 Second rank: EXE STATEMENT

p Following an EXE, another character is expected : the STATEMENT.
- \mi\m : Conditional statement
-
- \mf\m : For loop
-
- \mw\m : While loop
-
- \ms\m : Switch statement
-
- \mb\m : Break jump
-
- \mc\m : Continue jump
-
- \mr\m : Return jump
-
- \mv\m : Void Function Call
-
- \m\m : 
-
- \m\m : 
-
- \m\m : 
-
- \m\m : 
-
- \m\m : 
-
- \m\m : 
-
- \m\m : 
-
- \ma\m : Assignation
-

p In chibincc, the STATEMENT information is stored as part of the instruction ID : \
2nd, 3rd, 4th & 5th bits are used :
- \m0000\m : \mi\m
-
- \m0001\m : \mf\m
-
- \m0010\m : \mw\m
-
- \m0011\m : \ms\m
-
- \m0100\m : \mb\m
-
- \m0101\m : \mc\m
-
- \m0110\m : \mr\m
-
- \m0111\m : \mv\m
-
- \m1000\m : \m\m
-
- \m1001\m : \m\m
-
- \m1010\m : \m\m
-
- \m1011\m : \m\m
-
- \m1100\m : \m\m
-
- \m1101\m : \m\m
-
- \m1110\m : \m\m
-
- \m1111\m : \ma\m
-



t2 Third rank : DEF SCOPE KIND

p Following a DEF SCOPE, another character is expected : its KIND.
- \mc\m : Type Copy
-
- \ms\m : Structure type
-
- \mf\m : Function
-
- \md\m : Data item
-

p In chibincc, the KIND information is stored as part of the instruction ID : \
4th & 5th bits are used :
- \m00\m : \mc\m (type copy)
-
- \m01\m : \ms\m (structure type)
-
- \m10\m : \mf\m (function)
-
- \m11\m : \md\m (data item)
-




t2 Third rank : EXE STATEMENT details

t3 IF_ statement

"
EXE i <condition> <block> [next]
"
l If field "next" exists, it must be \mi\m ("else if") or \me\m (just "else") :
- \mEXE if_<condition><block>e<else_block>\m
No additionnal "next" field allowed.
-
- \mEXE i <condition> <block> i <condition> <else-if_block> [next]\m
Field "next" works the same as before (several chains allowed).
-
p Conditions are values. \
Blocks are aggregations of a certain number of instructions so we must use openning and closing braces delimiters \m{\m and \m}\m to know when they begin and when they end. \
Moreover, beginning from the condition to the very end, we have a succession of blocks once over 2.


t3 FOR statement

"
EXE f <itervar_type> <itervar_name> <itervar_value> <condition> <iterexe_name> <iterexe_value> <block>
"
p Each field is a value, even the iteration execution. \
As for if statements, blocks are aggregations of a certain number of instructions so we must use openning and closing braces delimiters \m{\m and \m}\m to know when they begin and when they end. \
The iteration execution is a couple name/value that will be used in asg() call.

t3 . statement

"
EXE xxx <condition> <block>
"



t2 Fourth rank : DEF SCOPE KIND details

t3 

DEF SCOPE cpy <type.src> <type.dst>

t3 

DEF SCOPE stc {...}

t3 

DEF SCOPE fct <name> <return_type> <params>

t3 

DEF SCOPE dat <behavior> <name> <value>






tu Last Note

p Please consider that NC is a FREE and OPEN SOURCE syntax completely architecture independant. \
Even if NC seems to be quite simple in general, the efforts to make a working and parsing-optimized syntax are to be considerated \
as those simplifications \bare\b what makes an NC-to-obj/ELF compiler that much efficient comparing to regular C compilers.

l This syntax as well as its specification took a certain amount of time, energy and thinking to be achieved.

lc Please respect the work done.

b

b

l Thanks for reading.
l I hope you will enjoy using this syntax to enhance the way we manage low-level programming nowadays (2024).

l Let's Code !\arBy I.A.
